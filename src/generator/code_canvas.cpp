/*
 * This file is distributed under the Apache License, Version 2.0; refer to
 * LICENSE for details.
 *
 * Initial author: Emanuel Vintila
 */

#include "code_canvas.h"

#include <cassert>
#include <sstream>

const std::string LICENSE =
  "/*\n"
  " * This file is distributed under the Apache License, Version 2.0; refer to\n"
  " * LICENSE for details.\n"
  " *\n"
  " * Generated by MSET 1.1.\n"
  " */\n"
  "\n";

CodeCanvas::CodeCanvas():
  number_of_globals(0),
  number_of_locals(0)
{
  code_lines = {
    "#include <unistd.h> // _exit", // 0
    "#include <stdint.h>", // 1
    "#include <stdlib.h>", // 2
    "#include <string.h>", // 3
    "",                    // 4
    "#ifdef ADDR_MASK",    // 5
    "#define GET_ADDR_BITS(p) ((size_t)(p) & ADDR_MASK)",   // 6
    "#else",                                                // 7
    "#define GET_ADDR_BITS(p) ((size_t)(p) & (size_t)0xffffffffffffull)",             // 8
    "#endif",                                               // 9
    "#ifndef MAX_OBJECT_SIZE",                              // 10
    "#define MAX_OBJECT_SIZE ((size_t)1 << 29)",            // 11
    "#endif",                                               // 12
    "",             // 13
    "volatile void *_use(volatile void *p) { return p; }",  // 14
    "const char content[8] = \"ZZZZZZZ\";",                 // 15
    "",             // 16
    "// types",     // 17
    "",             // 18
    "// globals",   // 19
    "",             // 20
    "",             // 21
    "int f()",      // 22
    "{",            // 23
    "  // locals",  // 24
    "",             // 25
    "",             // 26
    "",             // 27
    "  return 0;",  // 28
    "}",            // 29
    "",             // 30
    "int main()",   // 31
    "{",            // 32
    "  f();",       // 33
    "",             // 34
    "  return 0;",  // 35
    "}"             // 36
  };

  types_pos         = 18;
  global_start_pos  = 20;
  global_pos        = 21;
  locals_start_pos  = 25;
  locals_end_pos    = 26;
  start_of_f_pos    = 24;
  f_call_pos        = 33;
  current_pos_in_f  = locals_end_pos + 1;
  end_of_f_pos      = current_pos_in_f + 1;
  current_pos_in_main = f_call_pos + 1;
  current_pos_in_other_f = INVALID_CODE_POS;
  other_f_call_pos = INVALID_CODE_POS;
}

CodeCanvas::code_pos_t CodeCanvas::add_type(const std::vector<std::string> &lines)
{
  assert( types_pos != INVALID_CODE_POS );
  assert( types_pos < code_lines.size() );
  code_lines.insert(code_lines.begin() + types_pos, lines.begin(), lines.end());
  _update_indexes(types_pos, lines.size());
  return types_pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_global(const std::string &global)
{
  assert( global_pos != INVALID_CODE_POS );
  assert( global_pos < code_lines.size() );
  code_lines.insert(code_lines.begin() + global_pos, global);
  _update_indexes(global_pos, 1);
  ++number_of_globals;
  return global_pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_globals(const std::vector<std::string> &globals)
{
  code_pos_t pos = INVALID_CODE_POS;
  for ( const auto& global: globals ) pos = add_global(global);
  return pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_global_first(const std::string &global)
{
  assert( global_start_pos != INVALID_CODE_POS );
  assert( global_start_pos < code_lines.size() );
  code_lines.insert(code_lines.begin() + global_start_pos, global);
  _update_indexes(global_start_pos + 1, 1);
  ++number_of_globals;
  return global_start_pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_globals_first(const std::vector<std::string> &globals)
{
  code_pos_t pos = INVALID_CODE_POS;
  for ( const auto& global: globals ) pos = add_global_first(global);
  return pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_local(const std::string &line)
{
  ++number_of_locals;
  return add_at(locals_end_pos, std::vector<std::string>{line}, "  ");
}

CodeCanvas::code_pos_t CodeCanvas::add_locals(const std::vector<std::string> &locals)
{
  code_pos_t pos = INVALID_CODE_POS;
  for ( const auto& local: locals ) pos = add_local(local);
  return pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_local_first(const std::string &local)
{
  assert( locals_start_pos != INVALID_CODE_POS );
  assert( locals_start_pos < code_lines.size() );
  ++number_of_locals;
  code_lines.insert(code_lines.begin() + locals_start_pos, "  " + local);
  _update_indexes(locals_start_pos + 1, 1);
  return locals_start_pos + 1;
}

CodeCanvas::code_pos_t CodeCanvas::add_locals_first(const std::vector<std::string> &locals)
{
  code_pos_t pos = INVALID_CODE_POS;
  for ( const auto& local: locals ) pos = add_local_first(local);
  return pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_custom_section(const std::vector< std::string > &vars)
{
  code_pos_t pos = INVALID_CODE_POS;
  for ( const auto& var: vars ) pos = add_global("__attribute__((section(\".data.index\"))) " + var);
  return pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_f_body(const std::vector<std::string> &lines)
{
  assert( current_pos_in_f != INVALID_CODE_POS );
  assert( current_pos_in_f < code_lines.size() );
  std::vector<std::string> indented_lines{lines.size()};
  for ( size_t i = 0; i < lines.size(); i++ )
  {
    indented_lines[i] = "  " + lines[i];
  }
  code_lines.insert(code_lines.begin() + current_pos_in_f, indented_lines.begin(), indented_lines.end());
  _update_indexes(current_pos_in_f, lines.size());
  return current_pos_in_f;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_f_body(const std::string &line)
{
  return add_to_f_body(std::vector<std::string>{line});
}

CodeCanvas::code_pos_t CodeCanvas::add_to_f_body_end(const std::vector<std::string> &lines)
{
  assert( end_of_f_pos != INVALID_CODE_POS );
  assert( end_of_f_pos < code_lines.size() );
  std::vector<std::string> indented_lines{lines.size()};
  for ( size_t i = 0; i < lines.size(); i++ )
  {
    indented_lines[i] = "  " + lines[i];
  }
  code_lines.insert(code_lines.begin() + end_of_f_pos, indented_lines.begin(), indented_lines.end());
  _update_indexes(end_of_f_pos, lines.size());
  return end_of_f_pos;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_f_body_end(const std::string &line)
{
  return add_to_f_body_end(std::vector<std::string>{line});
}

CodeCanvas::code_pos_t CodeCanvas::add_to_other_f_body(const std::vector<std::string> &lines)
{
  if ( current_pos_in_other_f == INVALID_CODE_POS )
  {
    _generate_other_f_and_call();
  }
  assert( current_pos_in_other_f < code_lines.size() );
  std::vector<std::string> indented_lines{lines.size()};
  for ( size_t i = 0; i < lines.size(); i++ )
  {
    indented_lines[i] = "  " + lines[i];
  }
  code_lines.insert(code_lines.begin() + current_pos_in_other_f, indented_lines.begin(), indented_lines.end());
  _update_indexes(current_pos_in_other_f, lines.size());
  return current_pos_in_other_f;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_other_f_body(const std::string &line)
{
  return add_to_other_f_body(std::vector<std::string>{line});
}

CodeCanvas::code_pos_t CodeCanvas::add_to_main_body(const std::vector<std::string> &lines)
{
  if ( current_pos_in_main == INVALID_CODE_POS )
  {
    _generate_other_f_and_call();
  }
  assert( current_pos_in_main < code_lines.size() );
  std::vector<std::string> indented_lines{lines.size()};
  for ( size_t i = 0; i < lines.size(); i++ )
  {
    indented_lines[i] = "  " + lines[i];
  }
  code_lines.insert(code_lines.begin() + current_pos_in_main, indented_lines.begin(), indented_lines.end());
  _update_indexes(current_pos_in_main, lines.size());
  return current_pos_in_main;
}

CodeCanvas::code_pos_t CodeCanvas::add_to_main_body(const std::string &line)
{
  return add_to_main_body(std::vector<std::string>{line});
}

CodeCanvas::code_pos_t CodeCanvas::add_at(code_pos_t where, const std::vector<std::string> &lines, const std::string indent)
{
  assert( where != INVALID_CODE_POS );
  assert( where < code_lines.size() );
  std::vector<std::string> indented_lines{lines.size()};
  for ( size_t i = 0; i < lines.size(); i++ )
  {
    indented_lines[i] = indent + lines[i];
  }
  code_lines.insert(code_lines.begin() + where, indented_lines.begin(), indented_lines.end());
  _update_indexes(where, lines.size());
  return where + lines.size();
}

CodeCanvas::code_pos_t CodeCanvas::add_at(code_pos_t where, const std::string &line, const std::string indent)
{
  return add_at(where, std::vector<std::string>{line}, indent);
}

CodeCanvas::code_pos_t CodeCanvas::prefix_line_with(code_pos_t where, const std::string &what)
{
  assert( where != INVALID_CODE_POS );
  assert( where < code_lines.size() );
  code_lines[where] = what + code_lines[where];
  return where;
}

std::string CodeCanvas::to_string() const
{
  std::ostringstream result;

  result << LICENSE;

  result << "/*\n";
  for (const auto& str : test_case_description_lines)
  {
    result << " * " << str << "\n";
  }
  result << " * Variant:\n";
  for (const auto& str : variant_description_lines)
  {
    result << " *  - " << str << "\n";
  }
  result << " */\n\n";

  for (const auto& str : code_lines)
  {
    result << str << "\n";
  }
  return result.str();
}

void CodeCanvas::_generate_other_f_and_call()
{
  std::vector<std::string> other_f_body = {
    "int other_f()", // -5
    "{", // -4
    "", // -3
    "  return 0;", // -2
    "}", // -1
  };
  current_pos_in_other_f = add_at(global_pos + 1, other_f_body ) - 3;
  other_f_call_pos = add_at(f_call_pos + 1, "other_f();", "  ") - 1;
}

void CodeCanvas::_update_indexes(code_pos_t from, size_t amount)
{
  auto all_positions =   {&f_call_pos, &start_of_f_pos, &end_of_f_pos, &current_pos_in_f, &global_start_pos, &global_pos,
    &current_pos_in_other_f, &current_pos_in_main, &other_f_call_pos, &locals_start_pos, &locals_end_pos, &types_pos};
  for (auto pos: all_positions)
  {
    if ( *pos != INVALID_CODE_POS && *pos >= from )
    {
      assert( ( *pos + amount ) < code_lines.size() );
      *pos += amount;
    }
  }
}
