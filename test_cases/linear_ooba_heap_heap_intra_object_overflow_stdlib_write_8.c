/*
 * This file is distributed under the Apache License, Version 2.0; refer to
 * LICENSE for details.
 *
 * Generated by MSET 1.1.
 */

/*
 * Origin: heap
 * Target: heap
 * Bug type: intra-object, linear OOBA, overflow
 * Access type: stdlib, write
 * Variant: target declared after origin, distance is checked as it is, target reached by stdlib writing using an auxiliary pointer, target accessed by stdlib writing using auxiliary variables, stack auxiliary variables, declared last
 */

#include <unistd.h> // _exit
#include <stdint.h> // SIZE_MAX
#include <stdlib.h>
#include <string.h>

#ifdef ADDR_MASK
#define GET_ADDR_BITS(p) ((size_t)(p) & ADDR_MASK)
#else
#define GET_ADDR_BITS(p) ((size_t)(p) & (size_t)0xffffffffffffull)
#endif

volatile void *_use(volatile void *p) { return p; }
const char content[8] = "ZZZZZZZ";

// types
struct T
{
  char origin[8];
  char target[8];
};

// globals


int f()
{
  // locals

  volatile char * aux_ptr;
  volatile size_t step_distance;

  struct T *s = (struct T *)malloc( sizeof(struct T) );
  s->origin[0] = 0xAA;
  s->origin[1] = 0xAA;
  s->origin[2] = 0xAA;
  s->origin[3] = 0xAA;
  s->origin[4] = 0xAA;
  s->origin[5] = 0xAA;
  s->origin[6] = 0xAA;
  s->origin[7] = 0xAA;
  s->target[0] = 0xBB;
  s->target[1] = 0xBB;
  s->target[2] = 0xBB;
  s->target[3] = 0xBB;
  s->target[4] = 0xBB;
  s->target[5] = 0xBB;
  s->target[6] = 0xBB;
  s->target[7] = 0xBB;
  _use(s->target);
  _use(s->origin);
  if ( GET_ADDR_BITS(&aux_ptr) < GET_ADDR_BITS(s->target) && GET_ADDR_BITS(&aux_ptr) > GET_ADDR_BITS(s->origin) ) _exit(PRECONDITIONS_FAILED_VALUE);
  if ( GET_ADDR_BITS(&step_distance) < GET_ADDR_BITS(s->target) && GET_ADDR_BITS(&step_distance) > GET_ADDR_BITS(s->origin) ) _exit(PRECONDITIONS_FAILED_VALUE);
  if ( !((ssize_t)(GET_ADDR_BITS(s->target) - GET_ADDR_BITS(s->origin)) >= 0) ) _exit(PRECONDITIONS_FAILED_VALUE);
  aux_ptr = s->origin;
  while( GET_ADDR_BITS(aux_ptr) < GET_ADDR_BITS(s->target) )
  {
    step_distance = (GET_ADDR_BITS(s->target) > (1024 + GET_ADDR_BITS(aux_ptr))) ? 1024 : GET_ADDR_BITS(s->target) - GET_ADDR_BITS(aux_ptr);
    memset((void *)aux_ptr, 0xFF, step_distance);
    aux_ptr += step_distance;
    _use(aux_ptr);
  }
  _use(s->origin);
  volatile size_t size = 8;
  memset( (void *)aux_ptr, 0xFF, size);
  _use(aux_ptr);
  _exit(TEST_CASE_SUCCESSFUL_VALUE);

  free(s);
  return 0;
}

int main()
{
  f();

  return 0;
}
