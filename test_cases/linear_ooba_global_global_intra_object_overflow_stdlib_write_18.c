/*
 * This file is distributed under the Apache License, Version 2.0; refer to
 * LICENSE for details.
 *
 * Generated by MSET 1.1.
 */

/*
 * Origin: global
 * Target: global
 * Bug type: intra-object, linear OOBA, overflow
 * Access type: stdlib, write
 * Variant: target declared after origin, distance is checked as it is, target reached by stdlib writing using an auxiliary pointer, target accessed by stdlib writing using constants, global auxiliary variables, initialized, declared first
 */

#include <unistd.h> // _exit
#include <stdint.h> // SIZE_MAX
#include <stdlib.h>
#include <string.h>

#ifdef ADDR_MASK
#define GET_ADDR_BITS(p) ((size_t)(p) & ADDR_MASK)
#else
#define GET_ADDR_BITS(p) ((size_t)(p) & (size_t)0xffffffffffffull)
#endif

volatile void *_use(volatile void *p) { return p; }
const char content[8] = "ZZZZZZZ";

// types
struct T
{
  char origin[8];
  char target[8];
};

// globals
volatile size_t step_distance = 0;
volatile char * aux_ptr = 0;

struct T s = { {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}, {0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB} };

int f()
{
  // locals


  _use(s.target);
  _use(s.origin);
  if ( GET_ADDR_BITS(&aux_ptr) < GET_ADDR_BITS(s.target) && GET_ADDR_BITS(&aux_ptr) > GET_ADDR_BITS(s.origin) ) _exit(PRECONDITIONS_FAILED_VALUE);
  if ( GET_ADDR_BITS(&step_distance) < GET_ADDR_BITS(s.target) && GET_ADDR_BITS(&step_distance) > GET_ADDR_BITS(s.origin) ) _exit(PRECONDITIONS_FAILED_VALUE);
  if ( !((ssize_t)(GET_ADDR_BITS(s.target) - GET_ADDR_BITS(s.origin)) >= 0) ) _exit(PRECONDITIONS_FAILED_VALUE);
  aux_ptr = s.origin;
  while( GET_ADDR_BITS(aux_ptr) < GET_ADDR_BITS(s.target) )
  {
    step_distance = (GET_ADDR_BITS(s.target) > (1024 + GET_ADDR_BITS(aux_ptr))) ? 1024 : GET_ADDR_BITS(s.target) - GET_ADDR_BITS(aux_ptr);
    memset((void *)aux_ptr, 0xFF, step_distance);
    aux_ptr += step_distance;
    _use(aux_ptr);
  }
  _use(s.origin);
  memset( (void *)aux_ptr, 0xFF, 8);
  _use(aux_ptr);
  _exit(TEST_CASE_SUCCESSFUL_VALUE);

  return 0;
}

int main()
{
  f();

  return 0;
}
